{
	"tldrawFileFormatVersion": 1,
	"schema": {
		"schemaVersion": 2,
		"sequences": {
			"com.tldraw.store": 4,
			"com.tldraw.asset": 1,
			"com.tldraw.camera": 1,
			"com.tldraw.document": 2,
			"com.tldraw.instance": 25,
			"com.tldraw.instance_page_state": 5,
			"com.tldraw.page": 1,
			"com.tldraw.instance_presence": 5,
			"com.tldraw.pointer": 1,
			"com.tldraw.shape": 4,
			"com.tldraw.asset.bookmark": 2,
			"com.tldraw.asset.image": 5,
			"com.tldraw.asset.video": 5,
			"com.tldraw.shape.group": 0,
			"com.tldraw.shape.text": 2,
			"com.tldraw.shape.bookmark": 2,
			"com.tldraw.shape.draw": 2,
			"com.tldraw.shape.geo": 9,
			"com.tldraw.shape.note": 8,
			"com.tldraw.shape.line": 5,
			"com.tldraw.shape.frame": 0,
			"com.tldraw.shape.arrow": 5,
			"com.tldraw.shape.highlight": 1,
			"com.tldraw.shape.embed": 4,
			"com.tldraw.shape.image": 4,
			"com.tldraw.shape.video": 2,
			"com.tldraw.binding.arrow": 0
		}
	},
	"records": [
		{
			"gridSize": 10,
			"name": "",
			"meta": {},
			"id": "document:document",
			"typeName": "document"
		},
		{
			"meta": {},
			"id": "page:page",
			"name": "Page 1",
			"index": "a1",
			"typeName": "page"
		},
		{
			"id": "pointer:pointer",
			"typeName": "pointer",
			"x": 1774.1123409432744,
			"y": 1514.694738997798,
			"lastActivityTimestamp": 1734525084614,
			"meta": {}
		},
		{
			"followingUserId": null,
			"opacityForNextShape": 1,
			"stylesForNextShape": {
				"tldraw:textAlign": "start"
			},
			"brush": null,
			"scribbles": [],
			"cursor": {
				"type": "default",
				"rotation": 0
			},
			"isFocusMode": false,
			"exportBackground": true,
			"isDebugMode": false,
			"isToolLocked": false,
			"screenBounds": {
				"x": 0,
				"y": 0,
				"w": 1488,
				"h": 754.4000244140625
			},
			"insets": [
				false,
				false,
				true,
				false
			],
			"zoomBrush": null,
			"isGridMode": false,
			"isPenMode": false,
			"chatMessage": "",
			"isChatting": false,
			"highlightedUserIds": [],
			"isFocused": true,
			"devicePixelRatio": 1.25,
			"isCoarsePointer": false,
			"isHoveringCanvas": true,
			"openMenus": [],
			"isChangingStyle": false,
			"isReadonly": false,
			"meta": {},
			"duplicateProps": null,
			"id": "instance:instance",
			"currentPageId": "page:page",
			"typeName": "instance"
		},
		{
			"editingShapeId": "shape:3NC4Ks_nkY6k5VGzmdMM_",
			"croppingShapeId": null,
			"selectedShapeIds": [
				"shape:3NC4Ks_nkY6k5VGzmdMM_"
			],
			"hoveredShapeId": null,
			"erasingShapeIds": [],
			"hintingShapeIds": [],
			"focusedGroupId": null,
			"meta": {},
			"id": "instance_page_state:page:page",
			"pageId": "page:page",
			"typeName": "instance_page_state"
		},
		{
			"x": 280.71857949093015,
			"y": -177.69727176073616,
			"z": 0.3830972195224163,
			"meta": {},
			"id": "camera:page:page",
			"typeName": "camera"
		},
		{
			"x": 244.8000030517578,
			"y": 218.40000534057617,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"id": "shape:AlZ7tXqZRYaKaNUpsftM_",
			"type": "text",
			"props": {
				"color": "black",
				"size": "m",
				"w": 267.57501220703125,
				"text": "Threads Vs Processes",
				"font": "draw",
				"textAlign": "start",
				"autoSize": true,
				"scale": 1
			},
			"parentId": "page:page",
			"index": "a1",
			"typeName": "shape"
		},
		{
			"x": -263.77694012523136,
			"y": 292.16573389095834,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"id": "shape:0KRNdNFgwXogeFCFUrYZb",
			"type": "text",
			"props": {
				"color": "black",
				"size": "m",
				"w": 736.92140405313,
				"text": "Process will run within its own isolated memory space\nand can only talk to other processes through specific \nmechanisms such as Inter-Process Communication(IPC).\nModern CPU hardware has safe guards through paging\nthat ensures the process can only read and write from\nits own memory space. The all so common Segmentation \nFault is actually originally triggered by CPU hardware via a #PF (Page Fault) due to an illegal access.",
				"font": "draw",
				"textAlign": "start",
				"autoSize": false,
				"scale": 1
			},
			"parentId": "page:page",
			"index": "a26iz",
			"typeName": "shape"
		},
		{
			"x": 576.8434832799381,
			"y": 289.9621248577164,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"id": "shape:1KCyyyisvWu9U0Xdcf7s0",
			"type": "text",
			"props": {
				"color": "black",
				"size": "m",
				"w": 978.3397685554813,
				"text": "threads within the same process share the same address space. Access to the same address space can be a blessing and a curse. If a thread crashes, the state of the application may be unknown. There are no security protections in hardware preventing rogue threads from accessing other thread’s data in an unintended way. In fact, Chrome moved to running every browser tab in its own process instead of just using multiple threads. If you ever see the “Oh Snap…” in a Chrome tab, that is a process that executed something unintentional. The failed tab crashed and no longer running, but the remaining tabs can continue with business as usual",
				"font": "draw",
				"textAlign": "start",
				"autoSize": false,
				"scale": 1
			},
			"parentId": "page:page",
			"index": "a37w1",
			"typeName": "shape"
		},
		{
			"x": -274.19268865511225,
			"y": 609.5291328310645,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"id": "shape:8J9eug6jfG0IvL7PIfbKL",
			"type": "text",
			"props": {
				"color": "black",
				"size": "m",
				"w": 752.7986379524616,
				"text": "Copy-on-write (COW), also called implicit sharing or shadowing, is a resource-management technique used in programming to manage shared data efficiently. Instead of copying data right away when multiple programs use it, the same data is shared between programs until one tries to modify it. If no changes are made, no private copy is created, saving resources. A copy is only made when needed, ensuring each program has its own version when modifications occur. This technique is commonly applied to memory, files, and data structures.\nCopy-on-write finds its main use in operating systems, sharing the physical memory of computers running multiple processes, in the implementation of the fork() system call. Typically, the new process does not modify any memory and immediately executes a new process, replacing the address space entirely. It would waste processor time and memory to copy all of the old process's memory during the fork only to immediately discard the copy\n\nCopy-on-write can be implemented efficiently using the page table by marking certain pages of memory as read-only and keeping a count of the number of references to the page. When data is written to these pages, the operating-system kernel intercepts the write attempt and allocates a new physical page, initialized with the copy-on-write data, although the allocation can be skipped if there is only one reference. The kernel then updates the page table with the new (writable) page, decrements the number of references, and performs the write. The new allocation ensures that a change in the memory of one process is not visible in another's.",
				"font": "draw",
				"textAlign": "start",
				"autoSize": false,
				"scale": 1
			},
			"parentId": "page:page",
			"index": "a43mU",
			"typeName": "shape"
		},
		{
			"x": 618.6224453093232,
			"y": 619.8368517671099,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"id": "shape:Mi-pMCjeFaQg6-Uxy2byx",
			"type": "text",
			"props": {
				"color": "black",
				"size": "m",
				"w": 1077.539138726813,
				"text": "Doesn’t using processes require slow context switches?\nprocesses require context switches, but so do threads.\nA thread also has execution context attached to it which consists of it’s various CPU register values (such as EAX, EBX… in x86), among other things which needs to be stored before the next thread can start executing. In fact, modern SIMD code such as many of your video encoding and compression algorithms to watch  your favorite Netflix shows in HD shows use some pretty large registers which would need to write to memory. In fact, the latest incarnation of AVX consists of 32 64 byte wide registers",
				"font": "draw",
				"textAlign": "start",
				"autoSize": false,
				"scale": 0.9885292083872617
			},
			"parentId": "page:page",
			"index": "a53Yv",
			"typeName": "shape"
		},
		{
			"x": 614.788194499816,
			"y": 936.1291812055717,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"id": "shape:IhmJinThIoeO5yUCXPfM6",
			"type": "text",
			"props": {
				"color": "black",
				"size": "m",
				"w": 1162.560297229197,
				"text": "When referring to processes being slower than threads, usually the reference is not just the context switch itself but flushing entries in the Translation Lookaside Buffers (TLBs). TLBs holds cached translations of the paging mechanism we were referring to earlier. Because a new process will execute in its own memory space, it cannot use the old processes’s translations and will start fresh. This means the TLB will be cold for the new process. If a translation is not in the TLB, before the memory access can complete, a Page Miss Handler (PMH) needs to walk the page tables level by level. Page table walks are heavy pointer chasing algorithms and can slow load latency. There are shortcuts to minimize the number of levels required to walk, but the end issue is that a cold TLB can result in load latencies far greater than a warm TLB. This occurs even if the accessed variable is already in a CPU Cache somewhere (which we talk about later)\n\nSo the end conclusion is that the context switch for a process may not be a whole lot longer, but there can be lingering effects that slow down even post context.",
				"font": "draw",
				"textAlign": "start",
				"autoSize": false,
				"scale": 1
			},
			"parentId": "page:page",
			"index": "a63p8",
			"typeName": "shape"
		},
		{
			"x": 615.13760196316,
			"y": 1404.523813452687,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"id": "shape:3NC4Ks_nkY6k5VGzmdMM_",
			"type": "text",
			"props": {
				"color": "black",
				"size": "m",
				"w": 1158.9747389801144,
				"text": "Processes are not the only thing that can under go this cold TLB. Threads, if not scheduled on the same logical CPU (CPU Affinity), can also undergo this. Which brings up the next point: There are only a fixed number of logical CPUs that your application can run on. While a modern operating system has many processes and threads that can appear running simultaneously in various blocked and waits states, a CPU can only run a fixed number of threads at a time in reality. This is true regardless if the threads are in the same process or not. As you launch more threads then you can actively run, the operating system has to preemptively context switch. If you just spawn thread after thread for each task thinking it will run all in parallel, you may be surprised that you may be hurting performance more than running a small number of threads in a thread pool.\n\nIn general, a large number of threads can cause something called thrashing. Thrashing is a generic term used when the CPU starts swapping or moving resources around more than performing actual execution. A CPU has limited resource sizes, the TLBs, the caches, even the page tables allocated in memory are all limited. As you starting switching between more threads, you can put pressure on these subsystems causing evictions of still hot data, which can be detrimental to performance. Many asynchronous web frameworks are by default configured to match their worker thread pool to the real number of logical cores, or they may add a few extra for blocking, but still within an order of magnitude. Think of Uber drivers. Sometimes it’s easier and quicker to pick up passengers for longer trips and just drive for awhile then to be constantly picking up new passengers and dropping old ones off. The number of passengers is your fixed resources such as logical processors, cache size, and TLBs. If you pick up new passengers, you have to get rid of the old ones first to make room for the new ones. This in and out behavior is thrashing if you start finding yourself waiting for unloading and loading rather than just driving (doing work or execution)",
				"font": "draw",
				"textAlign": "start",
				"autoSize": false,
				"scale": 1
			},
			"parentId": "page:page",
			"index": "a72VB",
			"typeName": "shape"
		}
	]
}